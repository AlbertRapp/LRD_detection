---
output: html_document
theme: theme.scss
title: Simulation study
params:
  n_seeds: 100
  TMax: 150
editor_options: 
  chunk_output_type: console
---

```{r}
#| echo: false
all_times <- list()
knitr::knit_hooks$set(time_it = local({
  now <- NULL
  function(before, options) {
    if (before) {
      # record the current time before each chunk
      now <<- Sys.time()
    } else {
      # calculate the time difference after a chunk
      later <- Sys.time()
      interval <- lubridate::interval(now, later)
      # return a character string to show the time
      times <- list(
        chunk = options$label,
        sec = round(interval / lubridate::seconds(1), 2),
        min = round(interval / lubridate::minutes(1), 2),
        hours =  round(interval / lubridate::hours(1), 2)
      )
      all_times[[options$label]] <<- times
    }
  }
}))
knitr::opts_chunk$set(time_it = TRUE)
```


## Scope

This document is intented to run the described simulation study for **fractional Gaussian noise** time series of length **`r params$TMax`**.


## Import helper functions


```{r packages}
#| message: false
#| warning: false
setwd(here::here('01_finite_variance_simulations'))
source('../helpers/00_libraries.R')
source('../helpers/01_simulation_helpers.R')
source('../helpers/02_regression_helpers.R')
source('../helpers/03_evaluation_helpers.R')
```


## Define necessary parameters


```{r parameters}
Hs <- seq(0.3, 0.7, length.out = 12) # Hurst parameter
my_mset <- metric_set(accuracy, sens, spec)
n_seeds <- params$n_seeds # simulations per Hurst parameter and TMax
n_seeds
TMax <- params$TMax # ts length
TMax
```



## Simulate fGN time series


```{r simulate_fGNs}
# Enable parallel-processing
plan(multisession, workers = 7)
fGNs <- simulate_many_fGN(TMax, Hs, n_seeds)
print(fGNs, n = 2)
```


## Compute the periodograms and variances


```{r estimate_vars_and_periodograms}
vars_and_periodograms <- fGNs %>% 
  mutate(
    variance = future_map(ts_original, estimate_variances),
    periodogram = future_map(ts_original, estimate_periodogram)
  )
# Save as intermediate result
write_rds(
  vars_and_periodograms, 
  glue::glue('computed_data/vars_and_periodograms_{TMax}.rds')
)
print(vars_and_periodograms, n = 2)
```


Notice that the variance vectors are shorter because by default the variance is only estimated
until `TMax / 2`. 
This is done to save time because the regression is done on a smaller window anyway.

## Compute grid estimates

Now, we will compute grid estimates.

### Variance estimator

Let us begin with the variance estimator.


```{r grid_estimates_variance}
# We restrict our grid from above by TMax/3 because the variance estimator
# never performs well above this anyway.
grid <- compute_grid(TMax = TMax / 3)

variances <- vars_and_periodograms %>% 
  select(-periodogram)

grid_estimates <- variances %>% 
  mutate(
    grid_estimates = future_map(
      variance, 
      ~estimate_var_slope_grid(., grid = grid)
    )
  )
# Save as intermediate result
write_rds(
  grid_estimates, 
  glue::glue('computed_data/grid_estimates_{TMax}.rds')
)
```



### GPH estimator

Of course, we do the same thing for the GPH estimator.
Note that this estimator can use the full grid.


```{r grid_estimates_GPH}
grid_GPH <- compute_grid(TMax = TMax) 

periodograms <- vars_and_periodograms %>% 
  select(-c(variance, ts_original))


if (TMax <= 100) {
  # If TMax is small enough, then the grid estimates can be computed in one go
  grid_estimates_GPH <- compute_GPH_grid_estimates(periodograms, grid_GPH)
  
  # Save as intermediate result
  write_rds(
    grid_estimates_GPH, 
    glue::glue('computed_data/grid_estimates_GPH_{TMax}.rds')
  )
}

if (TMax > 100) {
  # If TMax is not small enough, then compute grid estimates in chunks
  # Split grid into chunks
  nrow_100 <- compute_grid(100) %>% nrow()
  n_grid_slices <- ceiling(nrow(grid_GPH) / nrow_100)
  set.seed(4635635)
  grid_GPH_slices <- split(
    grid_GPH, 
    sample(1:n_grid_slices, nrow(grid_GPH), replace=T)
  )
  
  # Run calculation for each chunk and save it on disk
  for (idx in seq_along(grid_GPH_slices)) {
    grid_slice <- grid_GPH_slices[[idx]]
    grid_estimates_GPH <- compute_GPH_grid_estimates(periodograms, grid_slice)
    
    # Save as intermediate result
    write_rds(
      grid_estimates_GPH, 
      glue::glue('computed_data/grid_estimates_GPH_{TMax}_{idx}.rds')
    )
  }

}











```


## Compute metrics for each cutoff


```{r compute_metrics}
metrics_var <- evaluate_metrics(grid_estimates, my_mset)

if (TMax <= 100) metrics_GPH <- evaluate_metrics(grid_estimates_GPH, my_mset)
if (TMax > 100) {
  metrics_GPH <- collect_metrics_GPH(dir = 'computed_data', TMax = TMax) %>% 
    evaluate_metrics(my_mset)
}

# Save as intermediate result
write_rds(
  metrics_var, 
  glue::glue('computed_data/metrics_var_{TMax}.rds')
)
write_rds(
  metrics_GPH, 
  glue::glue('computed_data/metrics_GPH_{TMax}.rds')
)
```


These metrics can be visualized as follows.


```{r}
#| echo: false
# camcorder::gg_record(
#   dir = 'img',
#   width = 16,
#   height = 9,
#   units = 'cm',
#   dpi = 300
# )

ggsave(
  filename = glue::glue('images/metrics_var_{TMax}.png'),
  plot = plot_metrics(metrics_var, uBd_max = TMax / 3),
  width = 16,
  height = 9,
  units = 'cm',
  dpi = 300,
  bg = 'white'
)


ggsave(
  filename = glue::glue('images/metrics_GPH_{TMax}.png'),
  plot = plot_metrics(metrics_GPH, uBd_max = TMax),
  width = 16,
  height = 9,
  units = 'cm',
  dpi = 300,
  bg = 'white'
)
```


### Variance estimator


```{r}
#| echo: false

knitr::include_graphics(glue::glue('images/metrics_var_{TMax}.png'))
```



### GPH estimator



```{r}
#| echo: false

knitr::include_graphics(glue::glue('images/metrics_GPH_{TMax}.png'))
```


We are mainly interested in comparability of the two estimators under best conditions.
So, let us compute the best overall cutoff values w.r.t. to Accuracy. 

::: {.grid}

::: {.g-col-12 .g-col-md-6}

### Top 5 - Variance estimator


```{r}
#| echo: false
metrics_var %>% 
  pivot_wider(names_from = metric, values_from = estimate) %>% 
  slice_max(Accuracy, n = 5, with_ties = F) %>% 
  gt::gt() %>% 
  gt::fmt_percent(columns = 3:5)
```


:::

::: {.g-col-12 .g-col-md-6}

### Top 5 - GPH estimator


```{r}
#| echo: false
metrics_GPH %>% 
  pivot_wider(names_from = metric, values_from = estimate) %>% 
  slice_max(Accuracy, n = 5, with_ties = F) %>% 
  gt::gt()  %>% 
  gt::fmt_percent(columns = 3:5)
```


:::

:::

## Time for simulations


```{r, time_it=FALSE}
#| echo: false
write_rds(all_times, 'all_times.rds')
saved_times <- read_rds('all_times.rds') %>% bind_rows() 
saved_times %>%
  add_row(
    chunk = 'total',
    sec = sum(saved_times$sec),
    min = sum(saved_times$min),
    hours = sum(saved_times$hours)
  ) %>% 
  filter(!str_detect(chunk, 'unnamed'))
```

